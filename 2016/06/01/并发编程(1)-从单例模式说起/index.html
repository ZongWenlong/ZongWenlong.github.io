<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>并发编程(1)-单例模式和volatile | All is well</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">并发编程(1)-单例模式和volatile</h1><a id="logo" href="/.">All is well</a><p class="description">Learn &amp; Cope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/movies/"><i class="fa fa-video-camera"> 电影</i></a><a href="/books/"><i class="fa fa-book"> 读书</i></a><a href="/future/"><i class="fa fa-heart"> 未来</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">并发编程(1)-单例模式和volatile</h1><div class="post-meta">Jun 1, 2016<span> | </span><span class="category"><a href="/categories/Technology/">Technology</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/06/01/并发编程(1)-从单例模式说起/" href="/2016/06/01/并发编程(1)-从单例模式说起/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#痛苦的回顾"><span class="toc-number">1.</span> <span class="toc-text">痛苦的回顾</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#问题的解决"><span class="toc-number">2.</span> <span class="toc-text">问题的解决</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#问题的由来"><span class="toc-number">2.1.</span> <span class="toc-text">问题的由来</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Volatile"><span class="toc-number">2.2.</span> <span class="toc-text">Volatile</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Other-Way"><span class="toc-number">3.</span> <span class="toc-text">Other Way?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Eager-initialization"><span class="toc-number">3.1.</span> <span class="toc-text">Eager initialization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Initialization-on-demand-holder-idiom"><span class="toc-number">3.2.</span> <span class="toc-text">Initialization-on-demand holder idiom</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-enum-way"><span class="toc-number">3.3.</span> <span class="toc-text">The enum way</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考文献"><span class="toc-number">4.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div><div class="post-content"><p>&emsp;&emsp;之前在找实习的时候，被N次问过，你用过什么设计模式么，或者你知道有什么设计模式么？每次我都只会羞愧的说，单例模式，面试官就会说，那就写一下吧。然后我就把直接背诵过得模板的写了出来。当时羞愧的原因是我只会一种设计模——单例模式。关于设计模式这个坑会在之后进行填补，现在的我才意识到还有个地方更应该感到羞愧——唯一看过的单例模式还写的有问题。</p>
<h1 id="痛苦的回顾"><a href="#痛苦的回顾" class="headerlink" title="痛苦的回顾"></a>痛苦的回顾</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这是我之前面试时写过的代码，记得当时还有面试官问过我这样写有什么问题么，甚至他还在提示我，多线程下会有什么问题么？我信誓旦旦的觉得反正加了synchronized了，就没有问题了。事实证明，我是too young, too simple！</p>
<h1 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的代码中，如果我们在为成员变量singleton添加volatile关键字进行修饰，原本的线程安全问题就会被解决，为什么呢？</p>
<h2 id="问题的由来"><a href="#问题的由来" class="headerlink" title="问题的由来"></a>问题的由来</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;           <span class="comment">//Point1: 线程A</span></span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(); <span class="comment">//Point2: 线程B</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对于这段代码，大家很容易就能明白，多线程环境下，这个单例是存在问题的。比如：假设线程A执行到Point1，线程B执行到Point2，那么线程A可能看到还未被线程B初始化完毕的singleton。所以就会出现问题。<br>对于instance = new Singleton();这一条语句可以大致分解为三步:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory = allocate();   <span class="comment">//1：分配对象的内存空间</span></span><br><span class="line">initObject(memory);    <span class="comment">//2：初始化对象</span></span><br><span class="line">instance = memory;     <span class="comment">//3：设置instance指向刚分配的内存地址</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;线程B可能正在初始化instance，线程A就得到了空的对象，也开始了初始化，这当然是违背单例的思想的。那是不是像我在开始部分的代码中加入synchronized同步块就可以了呢，因为这样可以保证这段代码在同一时间只有一个线程访问。<br>&emsp;&emsp;其实，这三条语句的顺序，并不一定是1,2,3顺序执行，由于编译器的原因，顺序可能变为1,3,2。也就是所谓的指令重排。如果是这样的话，那问题就严重了。线程B还没有初始化instance，线程A就可以再不进入同步块的前提下得到了一个非空的对象，然后就去使用了，这显然是有问题的。</p>
<h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p>为什么加上volatile后问题就不存在了呢？<br>volatile在Java中的保证如下：</p>
<ul>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。对volatile成员变量的读和写都是原子的。不会读到没有写入的值：只有读和写两个操作是原子的，像x++、x+=2这种表达式还是相当于先读，然后再写，两次进行，可以读到中间的值。即使是x=2这样的赋值操作，JVM并不能保证long,double这种64位数据类型（引用类型除外，它的读写始终都是原子的）读写的原子性，需要程序自己控制。另外过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。<blockquote>
<p>Some implementations may find it convenient to divide a single write action on a 64-bit long or double value into two write actions on adjacent 32 bit values. For efficiency’s sake, this behavior is implementation specific; Java virtual machines are free to perform writes to long and double values atomically or in two parts.<br>For the purposes of the Java programming language memory model, a single write to a non-volatile long or double value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64 bit value from one write, and the second 32 bits from another write. Writes and reads of volatile long and double values are always atomic. Writes to and reads of references are always atomic, regardless of whether they are implemented as 32 or 64 bit values.<br>VM implementers are encouraged to avoid splitting their 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as volatile or synchronize their programs correctly to avoid possible complications.<br>—— from JLS section 17.7: Non-atomic Treatment of double and long</p>
</blockquote>
</li>
</ul>
<ul>
<li>禁止指令重排序，对所有的volatile的变量的所有次读写操作，组成一个全局的全序关系。全序关系的意思是：任何两个操作之间都可以比较先后关系。这个全序关系叫“同步顺序”(synchronization order)。这个同步顺序和“程序顺序”(program order，也就是单个线程里各个操作的顺序)是一致的。根据这个顺序，每次读操作，看到的一定是它之前最后一次对同一个变量写的值，如果它之前没有对这个变量的写操作，就读到初始值（0、null、false）。这可以避免指令重排问题。</li>
</ul>
<p>总之，当我们加上volatile后，可以禁止语句2,3的重排序，也就可以避免多线程不安全问题。<br>既然谈到了volatile，它除了双重检查锁定外还有一些其他用途,如：状态标记量<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他的应用可以阅读：<a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">Java 理论与实践: 正确使用 Volatile 变量</a></p>
<h1 id="Other-Way"><a href="#Other-Way" class="headerlink" title="Other Way?"></a>Other Way?</h1><p>&emsp;&emsp;当修复了多线程安全问题后，是不是说上述方式就是单例模式的最佳实现呢？其实不是的，还有其他的单例模式的解决方案：<br>(PS: 前面提到的解决方案被成为Lazy initialization)</p>
<h2 id="Eager-initialization"><a href="#Eager-initialization" class="headerlink" title="Eager initialization"></a>Eager initialization</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类进行初始化时，static变量也会被初始化，并且JVM可以保证线程安全，即static部分只会被初始化一次，并且只有被初始化后才能被本线程或其他线程使用。（final域的对象具备初始化安全性，初始化安全性可以防止对象的初始引用被重排序到给构造过程之前。并且保证所有线程都能看由构造函数为final域设置的正确值）</p>
<h2 id="Initialization-on-demand-holder-idiom"><a href="#Initialization-on-demand-holder-idiom" class="headerlink" title="Initialization-on-demand holder idiom"></a>Initialization-on-demand holder idiom</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes singleton.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> SingletonHolder&#125; is loaded on the first execution of &#123;<span class="doctag">@link</span> Singleton#getInstance()&#125; or the first access to</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> SingletonHolder#INSTANCE&#125;, not before.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于静态内部类SingletonHolder，并不会在Singleton初始化时就初始化，只有SingletonHolder被第一次使用时即getInstance()被调用时，INSTANCE才会被初始化。</p>
<h2 id="The-enum-way"><a href="#The-enum-way" class="headerlink" title="The enum way"></a>The enum way</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span> <span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Perform operation here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>《Effective Java》一书中建议的实现Singleton的最佳方法</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><blockquote>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Singleton_pattern" target="_blank" rel="noopener">Singleton pattern</a></li>
<li><a href="http://ifeve.com/double-checked-locking-with-delay-initialization/" target="_blank" rel="noopener">双重检查锁定与延迟初始化</a></li>
<li><a href="https://bbs.byr.cn/#!article/Java/39220" target="_blank" rel="noopener">歪楼的volatile</a></li>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a></li>
</ol>
</blockquote>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://zongwenlong.github.io/2016/06/01/并发编程(1)-从单例模式说起/" data-id="cjpr0qffg0022oksvv9qtqmm8" class="article-share-link">分享到</a><div class="tags"><a href="/tags/设计模式/">设计模式</a><a href="/tags/并发/">并发</a><a href="/tags/多线程/">多线程</a></div><div class="post-nav"><a href="/2016/09/03/西藏游记（六人七天）/" class="pre">西藏游记（六人七天）</a><a href="/2016/05/25/Little-Tips/" class="next">Little Tips（持续更新）</a></div><div id="disqus_thread"><script>var disqus_shortname = 'http-zongwenlong-github-io';
var disqus_identifier = '2016/06/01/并发编程(1)-从单例模式说起/';
var disqus_title = '并发编程(1)-单例模式和volatile';
var disqus_url = 'http://zongwenlong.github.io/2016/06/01/并发编程(1)-从单例模式说起/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//http-zongwenlong-github-io.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Technology/">Technology</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Sort/" style="font-size: 15px;">Sort</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/C/" style="font-size: 15px;">C#</a> <a href="/tags/编程语言/" style="font-size: 15px;">编程语言</a> <a href="/tags/RESTful/" style="font-size: 15px;">RESTful</a> <a href="/tags/Cache/" style="font-size: 15px;">Cache</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/源码阅读/" style="font-size: 15px;">源码阅读</a> <a href="/tags/阳光灿烂/" style="font-size: 15px;">阳光灿烂</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/LaTeX/" style="font-size: 15px;">LaTeX</a> <a href="/tags/WordPress/" style="font-size: 15px;">WordPress</a> <a href="/tags/容器/" style="font-size: 15px;">容器</a> <a href="/tags/团队分享/" style="font-size: 15px;">团队分享</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/图搜索/" style="font-size: 15px;">图搜索</a> <a href="/tags/西藏/" style="font-size: 15px;">西藏</a> <a href="/tags/旅游/" style="font-size: 15px;">旅游</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/16/MoreEffectiveCSharp/">More Effective CSharp Notes</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/01/CSharpRampUp/">C# Ramp Up</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/latex-start/">LaTeX 学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/03/yangguangcanlan/">在这阳光灿烂的日子里</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/26/ReadingNotes-JavaConcurrencyInPractice/">读书笔记-《Java并发编程实战》</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/06/Java-SourceCode-Sort/">Java源码阅读-DualPivotQuicksort</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/23/Docker-常用命令/">Docker 常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/07/利用Docker快速搭建WordPress博客/">利用Docker快速搭建WordPress博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/18/RESTful-SpringMVC-Swagger-Demo/">RESTful SpringMVC Swagger Demo</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/03/西藏游记（六人七天）/">西藏游记（六人七天）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//http-zongwenlong-github-io.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://github.com/" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://www.haomwei.com/technology/maupassant-hexo.html" title="Maupassant" target="_blank">Maupassant</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">All is well.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-77720589-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?28aa9a092a9c1d26ba2a3b5d6f2c7c60";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>